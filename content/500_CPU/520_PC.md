---
title: 'Program counter'
pre: "<i class='fas fa-pen-square'></i> "
chapter: false
weight: 520
draft: false
---

De program counter is als vingertje van een kind dat leert lezen. Het duidt aan waar het gebleven is, welke regel er gelezen moet worden. Dit is ook de functie van de program counter (PC). De PC duidt aan welke instructie er momenteel uitgevoerd wordt. Wanneer de instructie uitgevoerd is, moet de *vinger* een plaats verschoven worden.

{{% multiHcolumn %}}
{{% column %}}
{{% figure src="/images/500/program_counter.png" title="" %}}
{{% /column %}}
{{% column %}}
De program counter houdt de *regelnummer* naar de juiste instructie bij. Deze staat opgeslagen in een 32-bit breed register. Na het uitvoeren van een instructie dient de PC verhoogd te worden met **0x4**.

In een programma wordt er ook vaak een **sprong** gedaan. Dit wilt zeggen dat de program counter een stuk verderop (of terug) moet gaan voor de volgende instructie aan te duiden. In de hardware kan dit geïmplementeerd worden door de **controle** signalen correct aan te sturen.
{{% /column %}}
{{% /multiHcolumn %}}

### Waarom 0x4?

Het is je misschien opgevallen dat er bij een verhoging van de progam counter, verhoogd wordt met 0x4. Alhoewel dit verwarrend kan overkomen is de reden hiervoor echter simpel.

{{% multiHcolumn %}}
{{% column %}}
Het geheugen waarin het programma opgeslagen zit, werkt op byte-niveau. Dit wilt zeggen: iedere byte die opgeslagen is, is bereikbaar op één welbepaald adres.

De processor werkt echter met een 32-bit bus. Dit wilt zeggen dat er **altijd** 32 bits (of 4 bytes) gelezen en/of geschreven worden. Aangezien een de breedte van 1 instructie ook 32 bits is, komt dit dus overeen met 1 overdracht over de bus. Dit wilt echter ook zeggen dat de volgende instructie 4 *addressen* verder staat.
{{% /column %}}
{{% column %}}
{{% figure src="/images/500/imem.png" title="" %}}
{{% /column %}}
{{% /multiHcolumn %}}

### ... start your engines

Voordat de processor geïmplementeerd kan worden, moet dus eerst de program counter gemaakt worden.

<!-- Different types for notices are: info (yellow), tip (green), warning (red), note (blue)-->
{{% notice tip %}}
Voordat je (ongetwijfeld met vol enthousiasme) een Vivado project maakt en code begint te schijven, **blijft** het belangrijk om eerst een design te maken!!
{{% /notice %}}

{{% multiHcolumn %}}
{{% column %}}
Hiernaast wordt de volledige set van instructie voor de RISC-V weergeven. Om precies te zijn, dit is de volledige set van instructie voor de basis RISC-V 32i (RV32i) instructies.

In deze lijst zijn er 8 instructies die een effect hebben op de program counter. De eerste 6 gemarkeerde instructies zijn de **conditional branch** instructies: **beq**, **bne**, **blt**, **bge**, **bltu** en **bgeu**.
Bij deze instructies zal er (indien aan de vooropgestelde voorwaarde voldaan is) een **relatieve jump** gebeuren. Het *adres* waarnaar er gesprongen wordt is een *offset* ten opzichte van de huidige waarde van de program counter.
Bij de laatste gemarkeerde instructies kan een **relatieve jump** en een **absolute jump** gedaan worden.

Er kan dus geconcludeerd worden dat, bij een jump, de waarde van de program counter **altijd het resultaat is van een som**:
* van de PC zelf en een offset
* van een register en een offset

Indien er geen jump is, is de waarde van de program counter de som:
* van de PC zelf en de constante 0x4
{{% /column %}}
{{% column %}}
{{% figure src="/images/500/instructions_PC.png" title="" %}}
{{% /column %}}
{{% /multiHcolumn %}}

Met dit inzicht, een blaadje papier met een potlood (en een gom), enkele tassen koffie of thee (of water), kan een design gemaakt worden. Bijvoorbeeld:

{{% multiHcolumn %}}
{{% column %}}
{{% figure src="/images/500/PC_design_2.png" title="" %}}
{{% /column %}}
{{% column %}}
{{% figure src="/images/500/PC_design.png" title="" %}}
{{% /column %}}
{{% column %}}
{{% figure src="/images/500/PC_design_3.png" title="" %}}
{{% /column %}}
{{% /multiHcolumn %}}



{{% multiHcolumn %}}
{{% column %}}
Ongeacht de keuze van het design, ziet de entity voor de program counter er (quasi) hetzelfde uit.

* clock en synchrone, actief hoge reset
* twee 32-bit data ingangen
* één 32-bit data uitgang
* 2 controle signalen:
  * **abs_rel_b** is '1' bij een absolute sprong en '0' bij een relatieve
  * **immediate** is '1' voor een relatieve sprong met offset en '0' bij een (standaard) sprong met 4
{{% /column %}}
{{% column %}}
{{< include_file "/static/hdlsrc/500/program_counter.vhd" "vhdl" >}}
{{% /column %}}
{{% /multiHcolumn %}}

{{% notice note %}}
Je kan de **ripple carry adder van opdracht 2** gebruiken.
Merk ook op dat de **immediate** ingang geen rol speel bij een **absolute jump**
{{% /notice %}}

Een testbench voor de program counter kan je hier vinden: {{< include_file "/static/hdlsrc/500/program_counter_tb.vhd" "vhdl" >}}