---
title: 'Program counter'
pre: "<i class='fas fa-pen-square'></i> "
chapter: false
weight: 520
draft: false
---

De program counter is als vingertje van een kind dat leert lezen. Het duidt aan waar het gebleven is, welke regel er gelezen moet worden. Dit is ook de functie van de program counter (PC). De PC duidt aan welke instructie er momenteel uitgevoerd wordt. Wanneer de instructie uitgevoerd is, moet de *vinger* een plaats verschoven worden.

{{% multiHcolumn %}}
{{% column %}}
{{% figure src="/images/500/program_counter.png" title="" %}}
{{% /column %}}
{{% column %}}
De program counter houdt de *regelnummer* naar de juiste instructie bij. Deze staat opgeslagen in een 32-bit breed register. Na het uitvoeren van een instructie dient de PC verhoogd te worden met **0x4**. Dit wordt hiernaast aangegeven met de **inc**(crement) ingang.

In een programma wordt er ook vaak een **sprong** gedaan. Dit wilt zeggen dat de program counter een stuk verderop (of terug) moet gaan voor de volgende instructie aan te duiden. In de hardware kan dit geïmplementeerd worden door een **load** te doen.
{{% /column %}}
{{% /multiHcolumn %}}

### Waarom 0x4?

Het is je misschien opgevallen dat er bij een verhoging van de progam counter, verhoogd wordt met 0x4. Alhoewel dit verwarrend kan overkomen is de reden hiervoor echter simpel.

{{% multiHcolumn %}}
{{% column %}}
Het geheugen waarin het programma opgeslagen zit, werkt op byte-niveau. Dit wilt zeggen: iedere byte die opgeslagen is, is bereikbaar op één welbepaald adres.

De processor werkt echter met een 32-bit bus. Dit wilt zeggen dat er **altijd** 32 bits (of 4 bytes) gelezen en/of geschreven worden. Aangezien een de breedte van 1 instructie ook 32 bits is, komt dit dus overeen met 1 overdracht over de bus. Dit wilt echter ook zeggen dat de volgende instructie 4 *addressen* verder staat.
{{% /column %}}
{{% column %}}
{{% figure src="/images/500/imem.png" title="" %}}
{{% /column %}}
{{% /multiHcolumn %}}

### ... start your engines

Voordat de processor geïmplementeerd kan worden, moet dus eerst de program counter gemaakt worden.

De program counter heeft 5 input signalen. **data_in, clock, reset, load en inc(rement)**. Als output heeft het **data_out**. Data_in en Data_out zijn beide 32-bit vectoren. Als de reset hoog wordt, moet de program counter **synchroon resetten** naar 0x0. **inc** zorgt dat de program counter met 4 verhoogd wordt en **load** zorgt ervoor dat de **data** van data_in **synchroon** wordt **ingeladen**. **Load heeft voorrang op increment**.

De program counter moet dus aan onderstaande specificaties voldoen:

* Als **reset** 1 is, wordt er **synchroon gereset** (*synchrone, actief hoge reset*)
* Als reset, load en inc 0 zijn blijft de uitgang zijn waarde **behouden**
* Als **increment** 1 is, dan wordt de program counter met **4 verhoogd**
* Als **load** 1 is, dan wordt de inputdata de **gesampled**
* De **load** heeft voorang op **inc**

{{% notice note %}}
Je kan de **ripple carry adder van opdracht 2** gebruiken.
{{% /notice %}}

{{% multiHcolumn %}}
{{% column %}}
{{% figure src="/images/500/program_counter.png" title="Blokschema van de program counter"  %}}
{{% /column %}}
{{% column %}}
{{< include_file "/static/hdlsrc/500/program_counter.vhd" "vhdl" >}}
{{% /column %}}
{{% /multiHcolumn %}}

Een testbench voor de program counter kan je hier vinden: {{< include_file "/static/hdlsrc/500/program_counter_tb.vhd" "vhdl" >}}