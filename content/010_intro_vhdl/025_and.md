---
title: 'AND poort'
pre: "<i class='fas fa-book'></i> "
chapter: false
weight: 25
draft: false
---

Heb géén schrik van deze titel. We gaan zeker niet alle componenten 1-voor-1 afgaan :smiley:.

Uiteraard gaan complexere designs moeilijk te beschrijven zijn in één enkel bestand. Componenten kunnen hergebruikt worden in andere componenten. Laat ons als voorbeeld een AND poort bouwen met behulp van de eerder geziene **NAND** poort en de **invertor**. Het schema van ons design ziet er dus als volgt uit.

<!-- {{% figure src="/images/intro/AND_gate_NAND_NOT.svg" title="AND gate"  %}} -->
{{% figure src="/images/drawio_new_and.png" title="De AND gate, gebouwd met behulp van een NAND en een invertor"  %}}


{{% multiHcolumn %}}
{{% column %}}
{{< highlight vhdl >}}

--------------------------------
-- KU Leuven - ESAT/COSIC - ES&S
--------------------------------
-- Module Name:     and_gate - Behavioural
-- Project Name:    Digitale elektronische schakelingen 
-- Description:     Een voorbeeld van een and-gate, gebouwd 
--                  met een nand en een invertor.
--
-- Revision     Date       Author     Comments
-- v0.1         20240118   VlJo       Initial version
--
--------------------------------
library IEEE;
-- gebruik de package STD_LOGIC_1164 uit de library 
use IEEE.STD_LOGIC_1164.ALL;

entity and_gate is
    port(
        A: IN STD_LOGIC;
        B: IN STD_LOGIC;
        Z: OUT STD_LOGIC
    );
end entity and_gate;

architecture Behavioural of and_gate is

    -- COMPONENT DECLARATIONS
    component inverter is
        port(
            A: IN STD_LOGIC;
            Z: OUT STD_LOGIC
        );
    end component inverter;

    component nand_gate is
        port(
            A: IN STD_LOGIC;
            B: IN STD_LOGIC;
            Z: OUT STD_LOGIC
        );
    end component nand_gate;

    -- (DE-)LOCALISING IN/OUTPUTS
    signal A_i : STD_LOGIC;
    signal B_i : STD_LOGIC;
    signal Z_i : STD_LOGIC;

    -- INTERNAL SIGNALS
    signal x : STD_LOGIC;

begin

    --------------------------------
    -- (DE-)LOCALISING IN/OUTPUTS
    --------------------------------
    A_i <= A;
    B_i <= B;
    Z <= Z_i;

    --------------------------------
    -- COMBINATORIAL
    --------------------------------
    nand_gate_inst00: component nand_gate port map(
        A => A_i,
        B => B_i,
        Z => X
    );
    
    inverter_inst00: component inverter port map(
        A => X,
        Z => Z_i     
    );

end Behavioural;
{{< /highlight >}}
{{% /column %}}
{{% column %}}
De beschrijving van deze AND poort begint met het gebruiken van een **package** (STD_LOGIC_1164) uit een **library** (IEEE).

Vervolgens is er opnieuw de **entity** block die aangeeft dat dit design 2 ingangspinnen heeft en 1 uitgangspin.

In de architecture verschijnt er iets nieuws. Tussen **architecture** en **begin** kunnen er declaraties gebeuren. Dit kunnen zowel declaraties zijn van signalen als van compontenten.

Als er andere *entities* gebruikt gaan worden, dan moeten we aangeven hoe deze er uit zien. Volgens ons schema gaan we gebruik maken van een NAND poort van en van een invertor. Deze twee component dienen dus gedeclareerd te worden.

{{% notice tip %}}
Merk op dat een component-declaratie exact hetzelfde beschreven wordt als de entity van de component zelf. Vervang het woordje *entity* door *component*.
{{% /notice %}}


De declaratie van een signaal is simpelweg duidelijk maken dat er een *draadje* gebruikt gaat worden, van een bepaald type en met een bepaalde naam.


## Een component instantiëren

Volgens het design dienen we 2 componenten te gebruiken. Beide zijn hierboven reeds gedeclareerd. Deze **declaratie** is enkel om de tools duidelijk te maken *hoe deze component er uit ziet*. 

Tussen de *begin* en *end* van de architecture kan er een **instantiatie** gemaakt worden van reeds gedeclareerde componenten.

Bi het instantieren kan er een naam gegeven worden aan de instantiatie. In het voorbeeld zijn de anmen *nand_gate_inst00* en *inverter_inst00*. Na de naamgeving wordt duidelijk gemaakt over welke component het gaat (*component nand_gate*). Uiteindelijk moet er **port map** gebeuren. Iedere in- en uitgang moet ergens aan gehangen worden. Dit kan soms een beetje verwarrend lijken, maar het idee is dat er voor iedere in- en uitgang het volgende staat:
<center><b>LINKS => RECHTS (komma)</b></center>

LINKS staat de naam van de poort van de component, RECHTS staat de naam van het signaal dat hierop aangesloten wordt.

Verschillende poorten worden gescheiden door een komma (,). Dit wilt dus zeggen dat er na de laatste mapping geen komma meer mag volgen.

{{% /column %}}
{{% /multiHcolumn %}}

In de bovenstaande beschrijving van de AND poort gebruiken we een NAND en een INV. Voor de volledigheid geven we nog even mee dat er ook een keyword **AND** bestaat: ```Z_i <= A_i AND B_i;``` was dus een perfect alternatief geweest :wink:.

## Alle lijnen ... tegelijk

In tegenstelling tot alle **software** die jullie tot hier toe geprogrameerd hebben, is er één heel belangrijk, conceptueel verschil met deze hardware beschrijving. Iedere lijn tussen de *begin* en *end* van de architecture wordt **TEGELIJKERTIJD** uitgevoerd. Het kan uiteraard (zoals in dit voorbeeld) dat het resultaat van één blok afhangt van het resultaat van een ander blok, maar zowel de NAND-gate als de invertor zijn <u>tegelijkertijd</u> aan het werken.

Denk nog eens terug aan de beschrijving op de MUDEC. Het IC met de AND poort werkt ook simultaan met het IC met de invertor.