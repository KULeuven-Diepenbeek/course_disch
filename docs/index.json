[
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/000_intro/",
	"title": "Introductie",
	"tags": [],
	"description": "",
	"content": "Introductie Welkom bij het labo van Digitale Elektronische Schakelingen. Het uiteindelijke doel van het labo is om een simpele processor te maken. We gaan een HACK-processor maken zoals in de MOOC (Massive Open Online Course) nand2tetris. We maken deze processor in de taal VHDL. VHDL (Very High Speed Integrated Circuit Hardware Description Language) is een hardware beschrijvings taal. Dat wil zeggen dat alle code die we in deze cursus schrijven, een beschrijving geeft van een schakeling die opgebouwd kan worden met digitale componenten.\nDe beschrijvingen die we maken in HDL kunnen gebruikt worden om FPGA\u0026rsquo;s mee te configureren of om ASIC\u0026rsquo;s (Application-Specific Integrated Circuits) mee te maken.\nBeoordeling 40% van de punten van dit opleidingsonderdeel staan op dit labo. 60% staat op de theorie.\nEr zijn 5 opdrachten die moeten ingediend worden via Toledo.\nEr is ook verplichte aanwezigheid in het labo. De labopunten worden evenredig met de afwezigheden van de student tijdens het labo gereduceerd. Bijvoorbeeld, als een student maar op 70% van de labozittingen aanwezig is, krijgt hij/zij 70% van het toegekende labopunt.\nBij opdracht 5 heb je nodig wat je in opdracht 3 en 4 gemaakt hebt!\nzelfstudie De zelfstudie VHDL wordt verwacht gelezen te worden in de loop van de lessen. De zelfstudie FSM is niet nodig voor deze labo\u0026rsquo;s. Er komen vragen van beide zelfstudie modules in het theorie examen!\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/001_software/010_alternatief/",
	"title": "Alternatieve omgeving",
	"tags": [],
	"description": "",
	"content": "Alternatief voor thuis Als het niet mogellijk is om Vivado te installaren op je eigen laptop, dan kan je de site EDA playground om toch thuis verder te kunnen werken. Je kan hierop inloggen met je Google account (van UHasselt). Zorg dat je bij testbench + design VHDL hebt geselecteerd. Nu kan je de code in de testbench (links) en het design (rechts) zetten. Als de code er in zit moet je ook de top entity van het design aangeven, deze naam moet je bij Top entity invulllen. Bij tools \u0026amp; simulators selecteren we GHDL. GHDL is een gratis simulator die niet zelf detecteert wanneer de code stopt dus bij de simulator options moet je nog zetten \u0026ndash;stop-time=50ns om aan te geven hoe lang er gesimuleerd moet worden. Als laatste moeten we nog aanvinken dat we de EPWave willen openen na de run. De eind tijd van stop-time moet je natuurlijk aanpassen als je langer wil simuleren.\nOm de simulatie te starten druk je vanboven op de run knop.\nscreenshot hoe een nand gate simuleren met EDA playground "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/001_software/",
	"title": "Ontwikkel omgeving",
	"tags": [],
	"description": "",
	"content": "Ontwikkel omgeving Naast de \u0026ldquo;integrated circuits\u0026rdquo; (in de volksmond ook wel \u0026ldquo;chips\u0026rdquo; genoemd ðŸ˜ƒ) die een vaste functionaliteit hebben, bestaan er ook speciale IC\u0026rsquo;s waarvan je de functionaliteit kan aanpassen. De logische poorten (Gates, in het Engels) in die IC\u0026rsquo;s zijn configureerbaar of programmeerbaar (Programmable, in het Engels). Als er zo een groot aantal gates gebundeld worden (in een Array, in het Engels) en deze kunnen ter plaatste (in the Field, in het Engels) geherprogrammeerd worden, noemen we deze IC\u0026rsquo;s Field Programmable Gate Arrays, oftewel FPGAs.\nDe FPGA-markt wordt gedomineerd door 2 grote fabrikanten van FPGA\u0026rsquo;s: AMD en Intel. Beide spelers samen leveren meer dan 85% van alle FPGAs wereldwijd. Het simuleren en configureren van FPGAs gebeurt in een speciale ontwikkelomgeving: Quartus voor Intel FPGA\u0026rsquo;s en Vivado (vroeger ISE) voor AMD FPGA\u0026rsquo;s.\nTer info \u0026hellip; de originele FPGA producenten waren Xilinx en Altera. AMD nam Xilinx over (2022) en Intel nam Altera over (2015).\nVivado Wij schrijven de HDL-code voor dit opleidingsonderdeel in Vivado. Vivado is de omgeving van AMD en wordt gebruik voor de huidige families van FPGAs. Je kan de software downloaden van de site van AMD. Je moet wel een (gratis) account aanmaken om de software te kunnen downloaden. Deze software is enkel beschikbaar voor Windows en Linux.\nVivado vereist veel opslagruimte om te installeren \u0026gt;100 GB. Door minder types van FPGA\u0026rsquo;s te ondersteunen kan hier wel wat bij bespaard worden!\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/010_intro_vhdl/",
	"title": "1. Eerste project",
	"tags": [],
	"description": "",
	"content": "Eerste project Image courtesy: pexels - Pixabay "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/010_intro_vhdl/010_eerste_project/",
	"title": "Eerste project",
	"tags": [],
	"description": "",
	"content": "Maak een project We starten met een eerste vivado project maken. We beginnen natuurlijk met vivado op te starten en te klikken op create project. Je geeft het project een naam en zorgt dat je het op een plaats zet waar je het nog kan terugvinden. Bij project type zeggen we RTL project en vinken we \u0026ldquo;Do not specify sources at this time\u0026rdquo; aan.\nDe volgende keuze die gemaakt moet worden is het type van FPGA. Als part maakt het niet veel uit wat we kiezen. Het beste is om een FPGA te kiezen die gratis is te gebruiken met Vivado zoals de xc7z020.\nLet er op dat je in het pad naar je Vivado project geen spaties hebt!! Dus, geen paden zoals \u0026ldquo;C:\\school\\2e jaar\\disch\u0026rdquo; of \u0026ldquo;C:\\mijn documenten\\demo\u0026rdquo;\nNu krijgen we een omgeving die er zo uit ziet. Voeg HDL code toe Na het maken van een project, kunnen we HDL code toevoegen. Dit kan via de link add sources. Vervolgens komt er een keuze om een nieuw bestand te maken of om een reeds bestaande file toe te voegen. Kies voor een nieuwe file en voeg een vhdl design source toe. De tool vraagt vervolgens voor I/O port definitions, die kan je al instellen bij het maken van de vhdl file, maar kunnen later ook nog aangepast worden in de code.\nMerk op dat Vivado al een kleine aanzet geeft om van te beginnen. Onderstaande VHDL-code geeft een beschrijving zorgt voor een invertor die, zoals verwacht, de ingang geÃ¯nverteerd doorgeeft aan de uitgang.\nlibrary IEEE; use IEEE.STD_LOGIC_1164.ALL; entity invertor is Port ( A: in std_logic; Z: out std_logic ); end invertor; architecture Behavioral of invertor is begin Z \u0026lt;= NOT A; end Behavioral; Dit is een eenvoudige VHDL beschrijving en we zullen deze in detail onder de loep nemen.\nentity invertor is Port ( A: in std_logic; Z: out std_logic ); end invertor; De entity definieert de input en de outputs van het (sub-)design dat we beschrijven. Het design heeft als naam gekregen: invertor. Vervolgens zien in de lijst van poorten dat deze component 2 poorten heeft: een ingang A en een uitgang Z.\nDeze component is dus een IC met twee pinnen en de entity blok omschrijft als het ware enkel de behuizing.\nDe tweede blok architecture beschrijft wat er IN de behuizing zit. Ook deze beschrijving kunnen we een naam geven: Behavioural. Alles wat er vervolgens beschreven wordt tussen de begin en end definieert het gedrag van de component.\narchitecture Behavioral of invertor is begin Z \u0026lt;= NOT A; end Behavioral; library IEEE; use IEEE.STD_LOGIC_1164.ALL; Tenslotte zijn er nog de eerste twee regels van de beschrijving. De eerste regel zegt dat er een library genaamd IEEE gebruikt wordt in deze beschrijving. De tweede regel zegt dat er uit deze library de package STD_LOGIC_1164 volledig (.ALL) gebruikt wordt. Wat dit precies wilt zeggen, daar wordt later op teruggekomen.\nHet is uitermate belangrijk dat het besef blijft dat VHDL (of iedere andere HDL) louter een beschrijving geeft van een hardware design. Dit wilt zeggen dat het mogelijk moet zijn een schema te tekenen !!!\nDe beschrijving van de de component hierboven is in een schema te tekenen als een invertor of NIET-poort.\nThe entity and architecture of the invertor std_logic Omdat we de package IEEE.STD_LOGIC_1164 gebruiken kunnen we het typen std_logic gebruiken. Dit is het type dat we meestal gebruiken wanneer we met signalen werken in een hardware beschrijving. std_logic kan 9 verschillende waardes aannemen. Meestal gebruiken we \u0026lsquo;0\u0026rsquo; en \u0026lsquo;1\u0026rsquo;. Hieronder zijn de mogellijke waardes opgelijst met uitleg.\n\u0026#39;U\u0026#39;, -- Uninitialized : flipflop waar nog nooit in is geschreven \u0026#39;X\u0026#39;, -- Forcing Unknown \u0026#39;0\u0026#39;, -- Forcing 0 : rechtstreeks aan grond \u0026#39;1\u0026#39;, -- Forcing 1 : rechtstreeks aan voeding \u0026#39;Z\u0026#39;, -- High Impedance \u0026#39;W\u0026#39;, -- Weak Unknown \u0026#39;L\u0026#39;, -- Weak 0 : via weerstand aan grond \u0026#39;H\u0026#39;, -- Weak 1 : via weerstand aan voeding \u0026#39;-\u0026#39;, -- Don\u0026#39;t Care"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/010_intro_vhdl/020_nand/",
	"title": "NAND poort",
	"tags": [],
	"description": "",
	"content": "De volgende stap is de beschrijving van een logisch NAND poort. Hiervoor maak je een nieuwe component aan in het Vivado project. Het grootste deel van de code van de invertor kunnen we overnemen als startpunt voor deze beschrijving.\nWe passen de entity aan zodat we 2 inputs hebben in plaats van 1. De behuizing van de nieuwe component zegt nu dat er 3 pinnen zijn: 2 input pinnen en 1 output pin.\nUiteraard moet het gedrag van deze component ook aangepast worden. In de architecture schrijven we dat we een NAND operatie willen doen. De basis poort NAND is ook beschikbaar als keyword in VHDL.\n-------------------------------- -- Revision Date Author Comments -- v0.2 20240118 VlJo Initial version -------------------------------- library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity nand_gate is Port ( A : in std_logic; B : in std_logic; Z : out std_logic ); end nand_gate; architecture Behavioral of nand_gate is -- (DE-)LOCALISING IN/OUTPUTS signal A_i : STD_LOGIC; signal B_i : STD_LOGIC; signal Z_i : STD_LOGIC; begin -------------------------------- -- (DE-)LOCALISING IN/OUTPUTS -------------------------------- A_i \u0026lt;= A; B_i \u0026lt;= B; Z \u0026lt;= Z_i; -------------------------------- -- COMBINATORIAL -------------------------------- Z_i \u0026lt;= A_i nand B_i; end Behavioral; NAND gate Nog enkele bijkomende opmerkingen: VHDL is case-insensitive. Je mag dus hoofdletters en kleine letters verwisselen. commentaar wordt vooraf gegaan van 2 min-tekens -- Het is good-practice om niet meteen te werken met de in- en uitgangen, maar met lokale signalen. Daarom wordt in dit voorbeeld deze \u0026ldquo;vertaalslag\u0026rdquo; gemaakt. commentaar kan NOOIT kwaad Voor deze simpele voorbeelden lijkt het banaal om de link met de discrete component (en de bijhorende schematic) te leggen. Een goede designer verliest echter het volledige schema NOOIT uit het oog.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/010_intro_vhdl/025_and/",
	"title": "AND poort",
	"tags": [],
	"description": "",
	"content": "Heb gÃ©Ã©n schrik van deze titel. We gaan zeker niet alle componenten 1-voor-1 afgaan ðŸ˜ƒ.\nUiteraard gaan complexere designs moeilijk te beschrijven zijn in Ã©Ã©n enkel bestand. Componenten kunnen hergebruikt worden in andere componenten. Laat ons als voorbeeld een AND poort bouwen met behulp van de eerder geziene NAND poort en de invertor. Het schema van ons design ziet er dus als volgt uit.\nDe AND gate, gebouwd met behulp van een NAND en een invertor -------------------------------- -- KU Leuven - ESAT/COSIC - ES\u0026amp;S -------------------------------- -- Module Name: and_gate - Behavioural -- Project Name: Digitale elektronische schakelingen -- Description: Een voorbeeld van een and-gate, gebouwd -- met een nand en een invertor. -- -- Revision Date Author Comments -- v0.1 20240118 VlJo Initial version -- -------------------------------- library IEEE; -- gebruik de package STD_LOGIC_1164 uit de library use IEEE.STD_LOGIC_1164.ALL; entity and_gate is port( A: IN STD_LOGIC; B: IN STD_LOGIC; Z: OUT STD_LOGIC ); end entity and_gate; architecture Behavioural of and_gate is -- COMPONENT DECLARATIONS component inverter is port( A: IN STD_LOGIC; Z: OUT STD_LOGIC ); end component inverter; component nand_gate is port( A: IN STD_LOGIC; B: IN STD_LOGIC; Z: OUT STD_LOGIC ); end component nand_gate; -- (DE-)LOCALISING IN/OUTPUTS signal A_i : STD_LOGIC; signal B_i : STD_LOGIC; signal Z_i : STD_LOGIC; -- INTERNAL SIGNALS signal x : STD_LOGIC; begin -------------------------------- -- (DE-)LOCALISING IN/OUTPUTS -------------------------------- A_i \u0026lt;= A; B_i \u0026lt;= B; Z \u0026lt;= Z_i; -------------------------------- -- COMBINATORIAL -------------------------------- nand_gate_inst00: component nand_gate port map( A =\u0026gt; A_i, B =\u0026gt; B_i, Z =\u0026gt; X ); inverter_inst00: component inverter port map( A =\u0026gt; X, Z =\u0026gt; Z_i ); end Behavioural; De beschrijving van deze AND poort begint met het gebruiken van een package (STD_LOGIC_1164) uit een library (IEEE).\nVervolgens is er opnieuw de entity block die aangeeft dat dit design 2 ingangspinnen heeft en 1 uitgangspin.\nIn de architecture verschijnt er iets nieuws. Tussen architecture en begin kunnen er declaraties gebeuren. Dit kunnen zowel declaraties zijn van signalen als van compontenten.\nAls er andere entities gebruikt gaan worden, dan moeten we aangeven hoe deze er uit zien. Volgens ons schema gaan we gebruik maken van een NAND poort van en van een invertor. Deze twee component dienen dus gedeclareerd te worden.\nMerk op dat een component-declaratie exact hetzelfde beschreven wordt als de entity van de component zelf. Vervang het woordje entity door component.\nDe declaratie van een signaal is simpelweg duidelijk maken dat er een draadje gebruikt gaat worden, van een bepaald type en met een bepaalde naam.\nEen component instantiÃ«ren Volgens het design dienen we 2 componenten te gebruiken. Beide zijn hierboven reeds gedeclareerd. Deze declaratie is enkel om de tools duidelijk te maken hoe deze component er uit ziet.\nTussen de begin en end van de architecture kan er een instantiatie gemaakt worden van reeds gedeclareerde componenten.\nBi het instantieren kan er een naam gegeven worden aan de instantiatie. In het voorbeeld zijn de anmen nand_gate_inst00 en inverter_inst00. Na de naamgeving wordt duidelijk gemaakt over welke component het gaat (component nand_gate). Uiteindelijk moet er port map gebeuren. Iedere in- en uitgang moet ergens aan gehangen worden. Dit kan soms een beetje verwarrend lijken, maar het idee is dat er voor iedere in- en uitgang het volgende staat:\nLINKS =\u003e RECHTS (komma) LINKS staat de naam van de poort van de component, RECHTS staat de naam van het signaal dat hierop aangesloten wordt.\nVerschillende poorten worden gescheiden door een komma (,). Dit wilt dus zeggen dat er na de laatste mapping geen komma meer mag volgen.\nIn de bovenstaande beschrijving van de AND poort gebruiken we een NAND en een INV. Voor de volledigheid geven we nog even mee dat er ook een keyword AND bestaat: Z_i \u0026lt;= A_i AND B_i; was dus een perfect alternatief geweest ðŸ˜‰.\nAlle lijnen \u0026hellip; tegelijk In tegenstelling tot alle software die jullie tot hier toe geprogrameerd hebben, is er Ã©Ã©n heel belangrijk, conceptueel verschil met deze hardware beschrijving. Iedere lijn tussen de begin en end van de architecture wordt TEGELIJKERTIJD uitgevoerd. Het kan uiteraard (zoals in dit voorbeeld) dat het resultaat van Ã©Ã©n blok afhangt van het resultaat van een ander blok, maar zowel de NAND-gate als de invertor zijn tegelijkertijd aan het werken.\nDenk nog eens terug aan de beschrijving op de MUDEC. Het IC met de AND poort werkt ook simultaan met het IC met de invertor.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/010_intro_vhdl/030_simulatie/",
	"title": "Simulatie",
	"tags": [],
	"description": "",
	"content": "Hoe kan er nu getest worden of onze nand poort correct werkt? We zouden een ASIC kunnen maken, maar dat zou een veel te dure en tijdrovende manier zijn.\nEen realistischere manier is om het design te implementeren op een FPGA, maar er is nog een gemakkelijkere en nuttigere manier: testbenches.\nHet idee achter een testbench is dat er \u0026ldquo;toestellen\u0026rdquo; zijn die inputs (ook stimuli genoemd) kunnen genereren. Vervolgens kunnen de waveforms van het hele design visueel geanalyseerd worden Ã©n kan de output van een component geverifieerd worden.\nIn dit opleidingsonderdeel krijgen jullie vaak de testbenches, maar het is goed om deze zelf aan te passen of uit te breiden.\nVoorbeeld: testbench voor een NAND poort Maken van een testbench Met onderstaande testbench kunnen we testen of onze nand poort werkt. Er moet een nieuwe simulation source aangemaakt worden en onderstaande testbench dient hierin geplakt te worden. Merk op dat ook de testbench geschreven is in (V)HDL.\nCommentaar Alhoewel dit geen verplicht stuk is, is het altijd nuttig om commentaar te voorzien.\nGebruik packages Deze testbench begint, net zoals de componenten, met het gebruiken van een package (STD_LOGIC_1164) uit een library (IEEE). Dit is uiteraard nodig omdat we anders geen definitie hebben van wat een STD_LOGIC type is.\nEen lege entitity Vervolgens is er ook een entity block. Merk hier zeker bij op dat een testbench typisch GEEN input en/of output poorten heeft.\nDeclaraties In de architecture gebeuren opnieuw eerst enkele declaraties. Zowel de component als de gebruikte signalen dienen gedeclareerd te worden.\nDUT Er wordt een component instantiatie gemaakt van de nand_gate in deze testbench. De naam van deze instantie is DUT, wat een acronym is van Device Under Test. UUT (Unit Under Test) wordt ook soms gebruikt\nStimuli Tenslotte is er nog Ã©Ã©n blok dat de stimuli beschrijft. Dit is een speciaal soort blok (een process) waar we later nog op terug komen. Wat er tussen de begin en end van een process beschreven staat, wordt sequentieel overlopen (hiermee wordt bedoeld: zoals bij een C-programma). Wees er echter van bewust dat de hele process-block TEGELIJKERTIJD loopt met de DUT.\nDe correcte werking van de NAND poort wordt in deze testbench nagegaan door alle mogelijke logische combinaties aan te leggen aan de ingangen van nullen en enen.\n-------------------------------- -- KU Leuven - ESAT/COSIC - ES\u0026amp;S -------------------------------- -- Module Name: nand_tb - Behavioural -- Project Name: Digitale eletronische schakelingen -- Description: Testbench for nand -- -- Revision Date Author Comments -- v1.0 20240118 VlJo Initial version -- -------------------------------- library IEEE; use IEEE.STD_LOGIC_1164.ALL; -- use IEEE.NUMERIC_STD.ALL; entity nand_tb is end entity nand_tb; architecture Behavioural of nand_tb is component nand_gate is port( A: IN STD_LOGIC; B: IN STD_LOGIC; Z: OUT STD_LOGIC ); end component nand_gate; signal input_a, input_b : STD_LOGIC; signal output_z : STD_LOGIC; begin -------------------------------- -- STIMULI -------------------------------- PSTIM: process begin input_a \u0026lt;= \u0026#39;0\u0026#39;; input_b \u0026lt;= \u0026#39;0\u0026#39;; wait for 10 ns; input_a \u0026lt;= \u0026#39;1\u0026#39;; input_b \u0026lt;= \u0026#39;0\u0026#39;; wait for 10 ns; input_a \u0026lt;= \u0026#39;0\u0026#39;; input_b \u0026lt;= \u0026#39;1\u0026#39;; wait for 10 ns; input_a \u0026lt;= \u0026#39;1\u0026#39;; input_b \u0026lt;= \u0026#39;1\u0026#39;; wait for 10 ns; wait; end process; -------------------------------- -- DUT -------------------------------- DUT: component nand_gate port map( A =\u0026gt; input_a, B =\u0026gt; input_b, Z =\u0026gt; output_z ); end Behavioural; Om een testbench toe te voegen aan het Vivado project is het belangrijk erop te letten dat je een Simulation source toevoegd. In deze testbench kan je vervolgens bovenstaande code plakken.\nRunnen van een testbench Als alle code beschreven is, kan de bovenstaante simulatie uitgevoerd worden. Er zijn meerdere manieren om een simulatie te starten en deze zul je ontdekken doorheen de labs.\nDe gemakkelijkste manier is om in de Flow Navigator (de verticale balk aan de linkerkant van het scherm) te klikken op: Run simulation. Als alles goed loop zou je (ongeveer) onderstaand scherm moeten krijgen.\nSimulatie van de nand gate met Vivado Je ziet hierin de inputs en de output van de DUT. De tijd verstrijkt over de X-as. Als beide inputs of Ã©Ã©n van beide inputs \u0026lsquo;hoog\u0026rsquo; is, is de uitgang ook \u0026lsquo;hoog\u0026rsquo;. Indien beide ingangen \u0026lsquo;hoog\u0026rsquo; zijn, is de uitgang \u0026rsquo;laag\u0026rsquo;.\nDat is exact wat een NAND poort moet doen !! (gelukkig)\nAls het design gesimuleerd wordt met een open-source simulator krijgen we een identiek resultaat.\nSimulatie van de nand gate met GHDL en GTKWave "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/010_intro_vhdl/031_synthesisable/",
	"title": "Synthetiseerbaar",
	"tags": [],
	"description": "",
	"content": "Synthesisable subset Tot hier hebben we gekeken naar de beschrijving van enkele discrete componenten. Deze componenten hebben beschreven in VHDL. Daarnaast hebben we een eerste testbench gemaakt ter verificatie van het ontwerp. Ook deze testbench is beschreven in VHDL. Dit is wellicht een goed moment om even aan te halen dat er ook andere HDL (hardware description languages) bestaan. Wellicht is de meest bekende (en meest gebruikte) taal verilog. De meest recente, wijd-verspreide taal is SystemVerilog, welke (zoals de naam doet vermoeden) gebaseeerd is op verilog. Dan zijn er ook nog HDLs die naar software talen leunen zoals: SystemC (C-like), MyHDL (Python-like) of Lava (Haskell-like).\nHet is belangrijk om te weten dat niet alle (V)HDL code synthesisable is. Wat wordt daarmee bedoeld?\nOf er nu voor FPGA of ASIC ontwikkeld wordt, de eerste stap van de toolchain is Synthesis. Tijdens de synthese wordt de HDL omgezet in een netlist. Dit is feitelijk niets anders dan een lijst van electronische componenten samen met een set van hoe deze verbonden zijn. Dit wilt dus zeggen: er moet een werkelijke component zijn voor (een deel van) de beschrijving.\nAlle keywords en constructies van een HDL waarvoor een fysieke implementatie bestaat wordt synthetiseerbare code genoemd:\nkeyword AND: is een beschrijving voor een logische poort poort richting IN: is een beschrijving voor een richting van een poort Z_i \u0026lt;= x: is het leggen een draadje tussen de draadjes Z_i en x In de testbench hebben we constructie gebruikt zoals wait for 10 ns;. Voor deregelijke instructies bestaat er geen fysieke implementatie. Deze code noemen we (surprise, surprise): niet-synthetiseerbare code.\nQuasi alle hardware beschrijvingstalen hebben zowel de mogelijkheid tot het schrijven van synthetiseerbare en niet-synthetiseerbare code. Dit eerste is voor designs te beschrijven, terwijl het tweede is om designs te testen.\nEnkele voorbeelden van niet-synthetiseerbare code: wait for 10ns; wait until ready = \u0026#39;1\u0026#39;; for i in 1 to 10 loop test_signaal \u0026lt;= NOT test_signaal; wait for 10ns; end loop; ..."
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/010_intro_vhdl/040_opdracht/",
	"title": "Opdracht 1: OR gate",
	"tags": [],
	"description": "",
	"content": "Als eerste opdracht in deze labo\u0026rsquo;s gaan jullie zelf een OR gate maken. In plaats van gebruik te maken van het OR keyword, moÃ©t deze gate gemaakt worden met uitsluitend NAND poorten. Maak hiervoor een nieuw bestand aan waarin je de beschrijving kwijt kan. Om te weten of de implementatie werkt, moet er ook een testbench geschreven worden. Deze kan dan gebruiken om het design te simuleren.\nDe schematic voor de OR poort (voor zij die het vergeten zouden zijn) is:\nOR gate De entity voor de OR poort moÃ©t als volgt zijn:\nentity or_gate is port( A : IN STD_LOGIC; B : IN STD_LOGIC; Z : OUT STD_LOGIC ); end entity or_gate; Opleveren Om deze opdracht op te leveren moeten jullie volgende bestanden indienen via Toledo:\nÃ©Ã©n (of meerdere) bestanden met het design Ã©Ã©n bestand met de testbench [OPTIONEEL] een markdown file met nodige uitleg Deze laatste is misschien nog niet nuttig voor deze opdracht, maar mogelijks wel voor latere opdrachten. Deze file geeft je de mogelijkheid om extra info mee te sturen.\nLaad enkel de bovenvernomende bestanden op in Toledo. Het is NIET de bedoeling om een volledig Vivado project te zippen en in te dienen !!\nDe VHDL broncode van de voorbeelden uit dit hoofdstuk kun je vinden op GitHub.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/920_cheat_sheet/",
	"title": "Cheat sheet",
	"tags": [],
	"description": "",
	"content": "Cheat sheet Algemeen VHDL \u0026bull; is een hoofdletterONgevoelige hardware beschrijvingstaal structuur librariesentityarchitecture libraries library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity entity lorem is \u0026nbsp; \u0026nbsp; A: in STD_LOGIC; \u0026nbsp; \u0026nbsp; B: in STD_LOGIC; \u0026nbsp; \u0026nbsp; Z: out STD_LOGIC_VECTOR(n-1 downto 0) end lorem -- direction kan zijn: in, out, inout, buffer, linkage architecture architecture x of y is \u0026nbsp; \u0026nbsp; -- declaraties van: constanten, signalen, componenten, .. begin \u0026nbsp; \u0026nbsp; -- beschrijving van het design end architecture; Entity VHDL \u0026bull; is een hoofdletterONgevoelige hardware beschrijvingstaal structuur librariesentityarchitecture libraries library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity entity lorem is \u0026nbsp; \u0026nbsp; A: in STD_LOGIC; \u0026nbsp; \u0026nbsp; B: in STD_LOGIC; \u0026nbsp; \u0026nbsp; Z: out STD_LOGIC_VECTOR(n-1 downto 0) end lorem -- direction kan zijn: in, out, inout, buffer, linkage architecture architecture x of y is \u0026nbsp; \u0026nbsp; -- declaraties van: constanten, signalen, componenten, .. begin \u0026nbsp; \u0026nbsp; -- beschrijving van het design end architecture; "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/",
	"title": "Digitale elektronische schakelingen",
	"tags": [],
	"description": "",
	"content": "Digitale elektronische schakelingen Image courtesy: pexels - Pixabay "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_disch/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]