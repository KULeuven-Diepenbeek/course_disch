<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>4. Sequentiële logica on Digitale Elektronische Schakelingen</title>
    <link>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/</link>
    <description>Recent content in 4. Sequentiële logica on Digitale Elektronische Schakelingen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-uk</language>
    <managingEditor>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Nele Mentens and Jo Vliegen)</managingEditor>
    <webMaster>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Nele Mentens and Jo Vliegen)</webMaster>
    <atom:link href="https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Intro Sequentiële logica</title>
      <link>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/410_intro_sequentieel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Nele Mentens and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/410_intro_sequentieel/</guid>
      <description>Zoals er eerder al aangehaald worden alle componenten tegelijkertijd uitgevoerd. Net zoals op een breadboard, zijn alle componenten en poorten gelijktijdig actief. Wanneer het ontwerp complexer wordt, is het bijna onmogelijk om iets realiseren als er geen orde of volgorde is. Hiervoor is het klok-signaal ontstaan. Dit signaal speelt een soortgelijke rol zoals die van een dirigent bij een concert.&#xA;Als we bij combinatorische logica de ingang veranderen, duurt het een zekere tijd voordat dat de uitgang (mogelijks) verandert.</description>
    </item>
    <item>
      <title>Registers</title>
      <link>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/420_registers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Nele Mentens and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/420_registers/</guid>
      <description>Een register wordt typisch gebruikt om data op te slaan. Een simpel register is een groep van D flipflops waar je data in kan laden en vervolgens data uit kan lezen. Op een stijgende flank van de clock zal, indien het load signaal hoog is, de data van de D ingang op de uitgang Q gezet.&#xA;Register Parallel in, parallel out </description>
    </item>
    <item>
      <title>Reset</title>
      <link>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/440_reset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Nele Mentens and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/440_reset/</guid>
      <description>Bij het maken van een hardware ontwerp dat registers bevat, is het noodzakelijk om de begintoestand te kennen: wat is de initiele waarde? De tekstboek manier om dit te bekomen is door gebruik te maken van een reset signaal. Het actief worden van dit signaal zorgt ervoor dat de hele schakeling in een gekende begintoestand komt. Er zijn typisch 2 manieren om dit te doen: met een synchrone reset of met een asynchrone reset.</description>
    </item>
    <item>
      <title>Meerdere registers</title>
      <link>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/450_morereg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Nele Mentens and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/450_morereg/</guid>
      <description>Het aantal ontwerpen dat je ooit zal maken dat minder dan 2 registers heeft, zal eerder beperkt zijn. Het beschrijven van registers neemt nogal wat regels HDL code in beslag. Stel dat er 2 registers in een design zijn: regA en regB. Een VHDL beschrijving van dit design zal ergens onderstaande twee stukken code bevatten.&#xA;PREGA: process(clock_i) begin if rising_edge(clock_i) then if reset_i = &amp;#39;1&amp;#39; then regA &amp;lt;= (others =&amp;gt; &amp;#39;0&amp;#39;); else if load_A = &amp;#39;1&amp;#39; then regA &amp;lt;= regA_in; end if; end if; end if; end process; PREGB: process(clock_i) begin if rising_edge(clock_i) then if reset_i = &amp;#39;1&amp;#39; then regB &amp;lt;= (others =&amp;gt; &amp;#39;0&amp;#39;); else if load_B = &amp;#39;1&amp;#39; then regB &amp;lt;= regB_in; end if; end if; end if; end process; Beide registers hebben een synchrone, actief hoge reset.</description>
    </item>
    <item>
      <title>Opdracht 4: Register file</title>
      <link>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/461_opdracht/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Nele Mentens and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/461_opdracht/</guid>
      <description>Na het maken van de ALU in de vorige opdracht, moet er voor opdracht 4 een Register file gemaakt worden.&#xA;Een register file is een onderdeel van een processor dat eigenlijk niet veel meer bevat dan een set registers. De specificaties van de register file voor deze opdracht zijn als volgt:&#xA;de data-breedte is 32 bits er zijn 8 registers in de register file de reg file beschikt over 2 lees-poorten src1 &amp;amp; data1 src2 &amp;amp; data2 de reg file beschikt over 1 schrijf-poort dest, data &amp;amp; we Blokschema van de register file Waveform van de register file Voor de lees-poorten wordt de src_x input gebruikt om de inhoud van het overeenkomende registeraan de data_x uitgang te zetten.</description>
    </item>
    <item>
      <title>Opdracht - testbench</title>
      <link>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/470_tb_opdracht/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Nele Mentens and Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_disch/400_sequentiele_logica/470_tb_opdracht/</guid>
      <description>Een variant van deze testbench wordt gebruikt voor de evaluatie.&#xA;-------------------------------------------------------------------------------- -- KU Leuven - ESAT/COSIC - Emerging technologies, Systems &amp;amp; Security -------------------------------------------------------------------------------- -- Module Name: regfile_tb - Behavioural -- Project Name: Testbench for regfile -- Description: Testbench for the register file -- -- Revision Date Author Comments -- v0.1 20250731 VlJo Initial version -- -------------------------------------------------------------------------------- library IEEE; use IEEE.STD_LOGIC_1164.ALL; -- use IEEE.NUMERIC_STD.ALL; entity regfile_tb is generic ( G_WIDTH : natural := 32; -- Width of the registers G_REGCOUNT_LOG2 : natural := 3 -- log2(C_REGCOUNT) ); end entity regfile_tb; architecture Behavioural of regfile_tb is component regfile is generic ( G_WIDTH : natural := 32; -- Width of the registers G_REGCOUNT_LOG2 : natural := 3 -- log2(C_REGCOUNT) ); port( clock : in STD_LOGIC; reset : in STD_LOGIC; we : in std_logic; src1 : in std_logic_vector(G_REGCOUNT_LOG2-1 downto 0); src2 : in std_logic_vector(G_REGCOUNT_LOG2-1 downto 0); dest : in std_logic_vector(G_REGCOUNT_LOG2-1 downto 0); data : in std_logic_vector(G_WIDTH-1 downto 0); data1 : out std_logic_vector(G_WIDTH-1 downto 0); data2 : out std_logic_vector(G_WIDTH-1 downto 0) ); end component regfile; signal clock_i : STD_LOGIC; signal reset_i : STD_LOGIC; signal we : STD_LOGIC; signal src1 : STD_LOGIC_VECTOR(G_REGCOUNT_LOG2-1 downto 0); signal src2 : STD_LOGIC_VECTOR(G_REGCOUNT_LOG2-1 downto 0); signal dest : STD_LOGIC_VECTOR(G_REGCOUNT_LOG2-1 downto 0); signal data : STD_LOGIC_VECTOR(G_WIDTH-1 downto 0); signal data1 : STD_LOGIC_VECTOR(G_WIDTH-1 downto 0); signal data2 : STD_LOGIC_VECTOR(G_WIDTH-1 downto 0); constant clock_period : time := 10 ns; begin ------------------------------------------------------------------------------- -- STIMULI ------------------------------------------------------------------------------- PSTIM: process variable good_checks : natural; variable bad_checks : natural; begin we &amp;lt;= &amp;#39;0&amp;#39;; src1 &amp;lt;= &amp;#34;000&amp;#34;; src2 &amp;lt;= &amp;#34;000&amp;#34;; dest &amp;lt;= &amp;#34;000&amp;#34;; data &amp;lt;= (others =&amp;gt; &amp;#39;0&amp;#39;); good_checks := 0; bad_checks := 0; wait until clock_i = &amp;#39;1&amp;#39;; wait until clock_i = &amp;#39;0&amp;#39;; wait for clock_period * 10; -- do readback ----------------------------------------------------------------------------- src1 &amp;lt;= &amp;#34;000&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;001&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;010&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;011&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;100&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;101&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;110&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;111&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; -- do write sweep ----------------------------------------------------------------------------- data &amp;lt;= x&amp;#34;00000001&amp;#34;; dest &amp;lt;= &amp;#34;001&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;00000002&amp;#34;; dest &amp;lt;= &amp;#34;010&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;00000003&amp;#34;; dest &amp;lt;= &amp;#34;011&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;00000004&amp;#34;; dest &amp;lt;= &amp;#34;100&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;00000005&amp;#34;; dest &amp;lt;= &amp;#34;101&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;00000006&amp;#34;; dest &amp;lt;= &amp;#34;110&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;00000007&amp;#34;; dest &amp;lt;= &amp;#34;111&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; -- do readback ----------------------------------------------------------------------------- src1 &amp;lt;= &amp;#34;000&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;001&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000001&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;010&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000002&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;011&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000003&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;100&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000004&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;101&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000005&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;110&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000006&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;111&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000007&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; -- do write sweep ----------------------------------------------------------------------------- data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;001&amp;#34;; we &amp;lt;= &amp;#39;0&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;010&amp;#34;; we &amp;lt;= &amp;#39;0&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;011&amp;#34;; we &amp;lt;= &amp;#39;0&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;100&amp;#34;; we &amp;lt;= &amp;#39;0&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;101&amp;#34;; we &amp;lt;= &amp;#39;0&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;110&amp;#34;; we &amp;lt;= &amp;#39;0&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;111&amp;#34;; we &amp;lt;= &amp;#39;0&amp;#39;; wait for clock_period; -- do readback ----------------------------------------------------------------------------- src1 &amp;lt;= &amp;#34;000&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;001&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000001&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;010&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000002&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;011&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000003&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;100&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000004&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;101&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000005&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;110&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000006&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src1 &amp;lt;= &amp;#34;111&amp;#34;; wait for clock_period; if data1 /= x&amp;#34;00000007&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; -- do write sweep ----------------------------------------------------------------------------- data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;001&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;010&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;011&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;100&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;101&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;110&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; data &amp;lt;= x&amp;#34;FFFFFFFF&amp;#34;; dest &amp;lt;= &amp;#34;111&amp;#34;; we &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period; -- do readback ----------------------------------------------------------------------------- src2 &amp;lt;= &amp;#34;000&amp;#34;; wait for clock_period; if data2 /= x&amp;#34;00000000&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src2 &amp;lt;= &amp;#34;001&amp;#34;; wait for clock_period; if data2 /= x&amp;#34;FFFFFFFF&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src2 &amp;lt;= &amp;#34;010&amp;#34;; wait for clock_period; if data2 /= x&amp;#34;FFFFFFFF&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src2 &amp;lt;= &amp;#34;011&amp;#34;; wait for clock_period; if data2 /= x&amp;#34;FFFFFFFF&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src2 &amp;lt;= &amp;#34;100&amp;#34;; wait for clock_period; if data2 /= x&amp;#34;FFFFFFFF&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src2 &amp;lt;= &amp;#34;101&amp;#34;; wait for clock_period; if data2 /= x&amp;#34;FFFFFFFF&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src2 &amp;lt;= &amp;#34;110&amp;#34;; wait for clock_period; if data2 /= x&amp;#34;FFFFFFFF&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; src2 &amp;lt;= &amp;#34;111&amp;#34;; wait for clock_period; if data2 /= x&amp;#34;FFFFFFFF&amp;#34; then bad_checks := bad_checks + 1; else good_checks := good_checks + 1; end if; report &amp;#34;DISCH_GRADING (good, bad, total): &amp;#34; &amp;amp; integer&amp;#39;image(good_checks) &amp;amp; &amp;#34; &amp;#34; &amp;amp; integer&amp;#39;image(bad_checks) &amp;amp; &amp;#34; &amp;#34; &amp;amp; integer&amp;#39;image(good_checks + bad_checks) &amp;amp; &amp;#34;&amp;#34; severity note; wait; end process; ------------------------------------------------------------------------------- -- DUT ------------------------------------------------------------------------------- DUT: component regfile generic map( G_WIDTH =&amp;gt; G_WIDTH, G_REGCOUNT_LOG2 =&amp;gt; G_REGCOUNT_LOG2 ) port map( clock =&amp;gt; clock_i, reset =&amp;gt; reset_i, we =&amp;gt; we, src1 =&amp;gt; src1, src2 =&amp;gt; src2, dest =&amp;gt; dest, data =&amp;gt; data, data1 =&amp;gt; data1, data2 =&amp;gt; data2 ); ------------------------------------------------------------------------------- -- CLOCK ------------------------------------------------------------------------------- PCLK: process begin clock_i &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period/2; clock_i &amp;lt;= &amp;#39;0&amp;#39;; wait for clock_period/2; end process PCLK; ------------------------------------------------------------------------------- -- RESET ------------------------------------------------------------------------------- PRST: process begin reset_i &amp;lt;= &amp;#39;1&amp;#39;; wait for clock_period*9; wait for clock_period/2; reset_i &amp;lt;= &amp;#39;0&amp;#39;; wait; end process PRST; end Behavioural; </description>
    </item>
  </channel>
</rss>
